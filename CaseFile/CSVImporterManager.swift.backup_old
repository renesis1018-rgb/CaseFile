import Foundation
import CoreData
import Combine

// MARK: - Import Step
enum ImportStep: Int, CaseIterable {
    case patient = 1
    case surgery = 2
    case labData = 3
    case followUp = 4
    
    var title: String {
        switch self {
        case .patient: return "æ‚£è€…åŸºæœ¬æƒ…å ±"
        case .surgery: return "æ‰‹è¡“æƒ…å ±"
        case .labData: return "è¡€æ¶²æ¤œæŸ»"
        case .followUp: return "çµŒéæƒ…å ±"
        }
    }
    
    var fileName: String {
        switch self {
        case .patient: return "01_æ‚£è€…åŸºæœ¬æƒ…å ±.csv"
        case .surgery: return "03_æ‰‹è¡“æƒ…å ±.csv"
        case .labData: return "02_è¡€æ¶²æ¤œæŸ».csv"
        case .followUp: return "04_çµŒéæƒ…å ±.csv"
        }
    }
    
    var icon: String {
        switch self {
        case .patient: return "person.fill"
        case .surgery: return "stethoscope"
        case .labData: return "cross.vial"
        case .followUp: return "chart.line.uptrend.xyaxis"
        }
    }
}

// MARK: - Import Error
struct ImportError: Identifiable {
    let id = UUID()
    let step: ImportStep
    let row: Int
    let message: String
}

// MARK: - CSV Importer Manager
@MainActor
class CSVImporterManager: ObservableObject {
    @Published var currentStep: ImportStep?
    @Published var progress: Double = 0.0
    @Published var status: String = "å¾…æ©Ÿä¸­"
    @Published var isImporting: Bool = false
    @Published var errors: [ImportError] = []
    
    @Published var patientCount: Int = 0
    @Published var surgeryCount: Int = 0
    @Published var labDataCount: Int = 0
    @Published var followUpCount: Int = 0
    
    @Published var completedSteps: Set<ImportStep> = []
    
    private let context: NSManagedObjectContext
    
    init(context: NSManagedObjectContext) {
        self.context = context
    }
    
    // MARK: - Import Single CSV
    func importCSV(step: ImportStep, from url: URL) async throws {
        isImporting = true
        currentStep = step
        status = "\(step.title)ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­..."
        
        // CSVãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
        let csvString = try String(contentsOf: url, encoding: .utf8)
        let lines = csvString.components(separatedBy: .newlines).filter { !$0.isEmpty }
        
        guard lines.count > 1 else {
            throw NSError(domain: "CSVImporter", code: 1,
                         userInfo: [NSLocalizedDescriptionKey: "CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã§ã™"])
        }
        
        let totalRows = lines.count - 1
        let headers = parseCSVLine(lines[0])
        
        print("ğŸ“‹ \(step.title): \(totalRows)è¡Œã®ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†")
        
        // ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«å‡¦ç†
        for (index, line) in lines.dropFirst().enumerated() {
            progress = Double(index + 1) / Double(totalRows)
            
            let values = parseCSVLine(line)
            
            do {
                switch step {
                case .patient:
                    try await importPatientRow(headers: headers, values: values, rowNumber: index + 2)
                    patientCount += 1
                case .surgery:
                    try await importSurgeryRow(headers: headers, values: values, rowNumber: index + 2)
                    surgeryCount += 1
                case .labData:
                    try await importLabDataRow(headers: headers, values: values, rowNumber: index + 2)
                    labDataCount += 1
                case .followUp:
                    try await importFollowUpRow(headers: headers, values: values, rowNumber: index + 2)
                    followUpCount += 1
                }
            } catch {
                errors.append(ImportError(
                    step: step,
                    row: index + 2,
                    message: error.localizedDescription
                ))
            }
            
            // å®šæœŸä¿å­˜
            if (index + 1) % 50 == 0 {
                try context.save()
            }
        }
        
        // æœ€çµ‚ä¿å­˜
        try context.save()
        
        completedSteps.insert(step)
        progress = 1.0
        status = "âœ… \(step.title)ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†"
        isImporting = false
    }
    
    // MARK: - Parse CSV Line
    private func parseCSVLine(_ line: String) -> [String] {
        var result: [String] = []
        var currentField = ""
        var insideQuotes = false
        
        for char in line {
            if char == "\"" {
                insideQuotes.toggle()
            } else if char == "," && !insideQuotes {
                result.append(currentField.trimmingCharacters(in: .whitespaces))
                currentField = ""
            } else {
                currentField.append(char)
            }
        }
        
        result.append(currentField.trimmingCharacters(in: .whitespaces))
        return result
    }
    
    // MARK: - Import Patient Row
    private func importPatientRow(headers: [String], values: [String], rowNumber: Int) async throws {
        var data: [String: String] = [:]
        for (index, header) in headers.enumerated() {
            if index < values.count {
                data[header] = values[index]
            }
        }
        
        guard let opeDateStr = data["Opeæ—¥"], !opeDateStr.isEmpty,
              let patientIdStr = data["æ‚£è€…ID"], !patientIdStr.isEmpty else {
            throw NSError(domain: "CSVImporter", code: 2,
                         userInfo: [NSLocalizedDescriptionKey: "Opeæ—¥ã¾ãŸã¯æ‚£è€…IDãŒç©ºã§ã™"])
        }
        
        // æ—¥ä»˜å¤‰æ›
        let opeDate = try parseDate(opeDateStr)
        
        // æ—¢å­˜Patientæ¤œç´¢
        let fetchRequest: NSFetchRequest<Patient> = Patient.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: "patientId == %@", patientIdStr)
        
        let patient: Patient
        if let existingPatient = try context.fetch(fetchRequest).first {
            patient = existingPatient
        } else {
            patient = Patient(context: context)
            patient.id = UUID()
            patient.patientId = patientIdStr
            patient.registeredDate = opeDate
        }
        
        // ãƒ‡ãƒ¼ã‚¿è¨­å®š
        patient.age = NSNumber(value: Int16(data["å¹´é½¢"] ?? "0") ?? 0)
        patient.gender = "å¥³æ€§"
        
        if let heightStr = data["èº«é•·(m)"], let height = Double(heightStr) {
            patient.heightCm = height * 100
        }
        
        if let bwStr = data["ä½“é‡(kg)"], let bw = Double(bwStr) {
            patient.bodyWeightKg = bw
        }
        
        if let bmiStr = data["BMI"], let bmi = Double(bmiStr) {
            patient.bmi = bmi
        }
        
        patient.smokingStatus = data["å–«ç…™æ­´"]
        patient.breastFeedingHistory = data["æˆä¹³æ­´"]
    }
    
    // MARK: - Import Surgery Row
    private func importSurgeryRow(headers: [String], values: [String], rowNumber: Int) async throws {
        var data: [String: String] = [:]
        for (index, header) in headers.enumerated() {
            if index < values.count {
                data[header] = values[index]
            }
        }
        
        guard let opeDateStr = data["Opeæ—¥"], !opeDateStr.isEmpty,
              let patientIdStr = data["æ‚£è€…ID"], !patientIdStr.isEmpty else {
            throw NSError(domain: "CSVImporter", code: 3,
                         userInfo: [NSLocalizedDescriptionKey: "Opeæ—¥ã¾ãŸã¯æ‚£è€…IDãŒç©ºã§ã™"])
        }
        
        let opeDate = try parseDate(opeDateStr)
        
        // Patientæ¤œç´¢
        let patientFetch: NSFetchRequest<Patient> = Patient.fetchRequest()
        patientFetch.predicate = NSPredicate(format: "patientId == %@", patientIdStr)
        
        guard let patient = try context.fetch(patientFetch).first else {
            throw NSError(domain: "CSVImporter", code: 4,
                         userInfo: [NSLocalizedDescriptionKey: "æ‚£è€…ID \(patientIdStr) ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"])
        }
        
        // Surgeryä½œæˆ
        let surgery = Surgery(context: context)
        surgery.id = UUID()
        surgery.surgeryDate = opeDate
        surgery.patient = patient
        surgery.surgeryCategory = "è„‚è‚ªæ³¨å…¥"
        surgery.surgeryType = "PureGraft"
        
        // NAC-IMF
        if let value = parseDouble(data["NAC-IMF(R)"]) {
            surgery.nacImfRight = value
        }
        if let value = parseDouble(data["NAC-IMF(L)"]) {
            surgery.nacImfLeft = value
        }
        
        // Skin thickness
        if let value = parseDouble(data["Skin_thickness(R)"]) {
            surgery.skinThicknessRight = value
        }
        if let value = parseDouble(data["Skin_thickness(L)"]) {
            surgery.skinThicknessLeft = value
        }
        
        // Injection Volume
        if let value = parseDouble(data["Injection_Volume(R)"]) {
            surgery.injectionVolumeRight = value
        }
        if let value = parseDouble(data["Injection_Volume(L)"]) {
            surgery.injectionVolumeLeft = value
        }
        
        surgery.harvestSite = data["æ¡å–éƒ¨ä½"]
        
        // æ³¨å…¥éƒ¨ä½
        if let value = parseDouble(data["çš®ä¸‹(R)"]) {
            surgery.subcutaneousRight = value
        }
        if let value = parseDouble(data["çš®ä¸‹(L)"]) {
            surgery.subcutaneousLeft = value
        }
        if let value = parseDouble(data["ä¹³è…ºä¸‹(R)"]) {
            surgery.submammaryRight = value
        }
        if let value = parseDouble(data["ä¹³è…ºä¸‹(L)"]) {
            surgery.submammaryLeft = value
        }
        if let value = parseDouble(data["å¤§èƒ¸ç­‹å†…ä¸‹(R)"]) {
            surgery.intramuscularRight = value
        }
        if let value = parseDouble(data["å¤§èƒ¸ç­‹å†…ä¸‹(L)"]) {
            surgery.intramuscularLeft = value
        }
    }
    
    // MARK: - Import LabData Row
    private func importLabDataRow(headers: [String], values: [String], rowNumber: Int) async throws {
        var data: [String: String] = [:]
        for (index, header) in headers.enumerated() {
            if index < values.count {
                data[header] = values[index]
            }
        }
        
        guard let opeDateStr = data["Opeæ—¥"], !opeDateStr.isEmpty,
              let patientIdStr = data["æ‚£è€…ID"], !patientIdStr.isEmpty else {
            return // è¡€æ¶²æ¤œæŸ»ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
        }
        
        let opeDate = try parseDate(opeDateStr)
        
        // Surgeryæ¤œç´¢
        let surgeryFetch: NSFetchRequest<Surgery> = Surgery.fetchRequest()
        surgeryFetch.predicate = NSPredicate(
            format: "surgeryDate == %@ AND patient.patientId == %@",
            opeDate as NSDate,
            patientIdStr
        )
        
        guard let surgery = try context.fetch(surgeryFetch).first else {
            throw NSError(domain: "CSVImporter", code: 5,
                         userInfo: [NSLocalizedDescriptionKey: "æ‰‹è¡“è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"])
        }
        
        // LabDataä½œæˆ
        let labData = LabData(context: context)
        labData.id = UUID()
        labData.surgery = surgery
        labData.testDate = opeDate
        
        // è¡€æ¶²æ¤œæŸ»ãƒ‡ãƒ¼ã‚¿
        if let value = parseDouble(data["ç™½è¡€çƒæ•°(WBC)"]) { labData.wbc = value }
        if let value = parseDouble(data["èµ¤è¡€çƒæ•°(RBC)"]) { labData.rbc = value }
        if let value = parseDouble(data["è¡€è‰²ç´ é‡(Hb)"]) { labData.hb = value }
        if let value = parseDouble(data["ãƒ˜ãƒãƒˆã‚¯ãƒªãƒƒãƒˆ(Ht)"]) { labData.ht = value }
        if let value = parseDouble(data["è¡€å°æ¿æ•°"]) { labData.plt = value }
        if let value = parseDouble(data["ç·è›‹ç™½(TP)"]) { labData.tp = value }
        if let value = parseDouble(data["å°¿é…¸(UA)"]) { labData.ua = value }
        if let value = parseDouble(data["å°¿ç´ çª’ç´ (UN)"]) { labData.bun = value }
        if let value = parseDouble(data["ã‚¯ãƒ¬ã‚¢ãƒãƒ‹ãƒ³(CREA)"]) { labData.cre = value }
        if let value = parseDouble(data["ç·ã‚³ãƒ¬ã‚¹ãƒ†ãƒ­ãƒ¼ãƒ«"]) { labData.tCho = value }
        if let value = parseDouble(data["ä¸­æ€§è„‚è‚ª(TG)"]) { labData.tg = value }
        if let value = parseDouble(data["ç·ãƒ“ãƒªãƒ«ãƒ“ãƒ³"]) { labData.tBil = value }
    }
    
    // MARK: - Import FollowUp Row
    private func importFollowUpRow(headers: [String], values: [String], rowNumber: Int) async throws {
        var data: [String: String] = [:]
        for (index, header) in headers.enumerated() {
            if index < values.count {
                data[header] = values[index]
            }
        }
        
        guard let opeDateStr = data["Opeæ—¥"], !opeDateStr.isEmpty,
              let patientIdStr = data["æ‚£è€…ID"], !patientIdStr.isEmpty,
              let period = data["çµŒéæœŸé–“"] else {
            return
        }
        
        let opeDate = try parseDate(opeDateStr)
        
        // Surgeryæ¤œç´¢
        let surgeryFetch: NSFetchRequest<Surgery> = Surgery.fetchRequest()
        surgeryFetch.predicate = NSPredicate(
            format: "surgeryDate == %@ AND patient.patientId == %@",
            opeDate as NSDate,
            patientIdStr
        )
        
        guard let surgery = try context.fetch(surgeryFetch).first else {
            throw NSError(domain: "CSVImporter", code: 6,
                         userInfo: [NSLocalizedDescriptionKey: "æ‰‹è¡“è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"])
        }
        
        // çµŒéæ—¥æ•°è¨ˆç®—
        let months: Int
        switch period {
        case "1M": months = 1
        case "3M": months = 3
        case "6M": months = 6
        default: months = 0
        }
        
        let followUpDate = Calendar.current.date(byAdding: .month, value: months, to: opeDate) ?? opeDate
        
        // FollowUpä½œæˆ
        let followUp = FollowUp(context: context)
        followUp.id = UUID()
        followUp.surgery = surgery
        followUp.followUpDate = followUpDate
        followUp.monthsAfterSurgery = NSNumber(value: months)
        followUp.smokingStatus = data["è¡“å¾Œå–«ç…™"]
        
        if let value = parseDouble(data["ä½“é‡"]) {
            followUp.bodyWeightKg = value
        }
    }
    
    // MARK: - Helpers
    private func parseDate(_ dateStr: String) throws -> Date {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(identifier: "Asia/Tokyo")
        
        guard let date = formatter.date(from: dateStr) else {
            throw NSError(domain: "CSVImporter", code: 7,
                         userInfo: [NSLocalizedDescriptionKey: "æ—¥ä»˜å½¢å¼ã‚¨ãƒ©ãƒ¼: \(dateStr)"])
        }
        
        return date
    }
    
    private func parseDouble(_ str: String?) -> Double? {
        guard let str = str, !str.isEmpty else { return nil }
        return Double(str)
    }
    
    // MARK: - Reset
    func reset() {
        currentStep = nil
        progress = 0.0
        status = "å¾…æ©Ÿä¸­"
        isImporting = false
        errors.removeAll()
        patientCount = 0
        surgeryCount = 0
        labDataCount = 0
        followUpCount = 0
        completedSteps.removeAll()
    }
}
